<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="api.css" type="text/css" rel="stylesheet" title="APIリファレンス用標準スタイル" />
<title>ShaderProgram - </title>
</head>
<body>
<h1><a name="top" id="top">ShaderProgram</a></h1>
<div class="para"><p>This class stores compiled/linked Vertex/Fragment shaders.<br />
Compilation/linking is performed in the constructor, and if there are errors, an exception will be thrown, so check the logs and fix them.<br />
Parameters used for shader input are added as members, so values can be set via members.<br />
Variable names from the shader are obtained using reflection.<br />
Specifications such as Texture are defined in advance as reserved words, and created with that name.<br />
Attribute values that are vertex information can only be set via members when using VertexBuffer/VertexBindre with drawMesh.<br />
Member functions and properties originally in ShaderProgram cannot be used as input variable names in the shader (therefore, currently only a minimum number of members are added).</p>

<p>If you set values for properties added as input names defined in the shader, that value will be set at the time of drawing.<br />
The added properties can only be set, not retrieved.<br />
The values are retained, so if you are using the same shader, you need to change the values you want to specify before drawing.<br />
The type of the property is obtained from the shader script.<br />
vec4 etc. are passed to the Array class as an array of real type.</p>

<p>Reserved words are automatically set internally at the time of drawing execution, so there is no need to explicitly set values (except for drawMesh).<br />
ex. The first texture id is passed to s_tex0.<br />
The automatically set values depend on the drawing command.</p>

<p>If shaders can be specified from a script and freely replaced, it is predicted that it will be possible to add effects with only TJS2 scripts, which is faster than conventional CPU processing, without writing a plugin to extend the functionality of the Layer as before.<br />
Although there is currently no Layer-equivalent function, if we enhance the peripheral functions necessary to implement Layer/Sprite etc. with TJS2 scripts, we can write around that with scripts, and reduce the number of native (C++) plugins compared to before.<br />
In Android, where binaries need to be prepared for multiple CPUs, being able to extend functionality with scripts also helps reduce the apk size.<br />
It is also advantageous for multi-platform.<br />
If you distribute a set of shaders + TJS2 scripts that implement Sprite etc. that handle them, you can enhance the presentation with that.</p>

<p>When inputting shader scripts from a file, please write in UTF-8.</p>

<p>Variable names that cannot be used in shaders (internally defined)</p>

<ul>
<li>ShaderProgram</li>
<li>finalize</li>
</ul>

<p>Names of automatically set values</p>

<ul>
<li>Texture : s_tex0, s_tex1, s_tex2, s_tex3...</li>
<li>Vertex coordinates : a_pos(vec2)</li>
<li>Texture coordinates : a_texCoord(vec2)</li>
<li>Matrix : a_modelMat4(mat4)</li>
</ul>

<p>GLSL structures and arrays are not supported in the initial stage.</p>
</div>
<h1>Members</h1><div class="para">
<dl>
<dt>Constructor</dt>
<dd>
<a class="jump" href="func_ShaderProgram_ShaderProgram.html">ShaderProgram</a> (Constructor)<br />
</dd>
<dt>Methods</dt>
<dd>
</dd>
<dt>Properties</dt>
<dd>
</dd>
<dt>Events</dt>
<dd>
</dd>
</dl>
</div>
</body>
</html>