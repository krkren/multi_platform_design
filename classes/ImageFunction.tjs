/**
 * @description ImageFunction class is a class for manipulating images.
 * You cannot create objects from this class.
 */
class ImageFunction {
	/**
	 * Affine transformation operation composition
	 *
	 * @param dst Specifies the Bitmap object to be overlaid.
	 * @param src Specifies the Bitmap object of the overlay source.
	 * @param A A parameter. The interpretation changes depending on the affine argument.
	 * @param B B parameter. The interpretation changes depending on the affine argument.
	 * @param C C parameter. The interpretation changes depending on the affine argument.
	 * @param D D parameter. The interpretation changes depending on the affine argument.
	 * @param E E parameter. The interpretation changes depending on the affine argument.
	 * @param F F parameter. The interpretation changes depending on the affine argument.
	 * @param srcrect Specifies the rectangle to be overlaid as a Rect object in pixel units (in the image position of the overlay source Bitmap).
	 * The entire area is targeted when unspecified.
	 * @param cliprect Specifies the clipping rectangle as a Rect object (in the image position of the overlay destination Bitmap).
	 * No clipping is performed when unspecified.
	 * @param affine Specifies how to handle the following six arguments (A to F parameters).
	 * If true is specified, the six parameters are interpreted as follows:
	 * A   : a of the 2D affine transformation matrix
	 * B   : b of the 2D affine transformation matrix
	 * C   : c of the 2D affine transformation matrix
	 * D   : d of the 2D affine transformation matrix
	 * E   : tx of the 2D affine transformation matrix
	 * F   : ty of the 2D affine transformation matrix
	 * By affine transformation, the image position (x, y) of the overlay source (however, the upper left corner of the overlay source rectangle is (0, 0)) is converted to the image position (x', y') of the overlay destination by the following formula.
	 * x' =  a*x + c*y + txy' =  b*x + d*y + ty
	 * If false is specified, the six parameters are interpreted as follows:
	 * A   : X coordinate position (x0) in the image position at the copy destination of the upper left corner point of the copy source rectangle
	 * B   : Y coordinate position (y0) in the image position at the copy destination of the upper left corner point of the copy source rectangle
	 * C   : X coordinate position (x1) in the image position at the copy destination of the upper right corner point of the copy source rectangle
	 * D   : Y coordinate position (y1) in the image position at the copy destination of the upper right corner point of the copy source rectangle
	 * E   : X coordinate position (x2) in the image position at the copy destination of the lower left corner point of the copy source rectangle
	 * F   : Y coordinate position (y2) in the image position at the copy destination of the lower left corner point of the copy source rectangle
	 * If false is specified, the overlay destination position (x3, y3) corresponding to the lower right corner of the overlay source is automatically calculated by the following formula.
	 * x3 = x1 - x0 + x2y3 = y1 - y0 + y2
	 * @param mode Specifies the operation mode.
	 *
	 * + If omPsNormal is specified, Photoshop-compatible alpha compositing is performed (not implemented in the current version).
	 * + If omPsAdditive is specified, Photoshop-compatible dodge (linear) compositing is performed (not implemented in the current version).
	 * + If omPsSubtractive is specified, Photoshop-compatible burn (linear) compositing is performed (not implemented in the current version).
	 * + If omPsMultiplicative is specified, Photoshop-compatible multiply compositing is performed (not implemented in the current version).
	 * + If omPsScreen is specified, Photoshop-compatible screen compositing is performed (not implemented in the current version).
	 * + If omPsOverlay is specified, Photoshop-compatible overlay compositing is performed (not implemented in the current version).
	 * + If omPsHardLight is specified, Photoshop-compatible hard light compositing is performed (not implemented in the current version).
	 * + If omPsSoftLight is specified, Photoshop-compatible soft light compositing is performed (not implemented in the current version).
	 * + If omPsColorDodge is specified, Photoshop-compatible color dodge compositing is performed (not implemented in the current version).
	 * + If omPsColorDodge5 is specified, color dodge compositing compatible with Photoshop version 5.x and earlier is performed (not implemented in the current version).
	 * + If omPsColorBurn is specified, Photoshop-compatible color burn compositing is performed (not implemented in the current version).
	 * + If omPsLighten is specified, Photoshop-compatible compare (light) compositing is performed (not implemented in the current version).
	 * + If omPsDarken is specified, Photoshop-compatible compare (dark) compositing is performed (not implemented in the current version).
	 * + If omPsDifference is specified, Photoshop-compatible absolute difference compositing is performed (not implemented in the current version).
	 * + If omPsDifference5 is specified, absolute difference compositing compatible with Photoshop version 5.x and earlier is performed (not implemented in the current version).
	 * + If omPsExclusion is specified, Photoshop-compatible exclusion compositing is performed (not implemented in the current version).
	 * + If omAdditive is specified, additive compositing is performed (not implemented in the current version).
	 * + If omSubtractive is specified, subtractive compositing is performed (not implemented in the current version).
	 * + If omMultiplicative is specified, multiplicative compositing is performed (not implemented in the current version).
	 * + If omDodge is specified, dodge compositing is performed (not implemented in the current version).
	 * + If omDarken is specified, compare (dark) compositing is performed (not implemented in the current version).
	 * + If omLighten is specified, compare (light) compositing is performed (not implemented in the current version).
	 * + If omScreen is specified, screen multiplication compositing is performed (not implemented in the current version).
	 * + If omAlpha is specified, alpha compositing is performed.
	 * + If omAddAlpha is specified, additive alpha compositing is performed. In this case, if face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear for the type argument.
	 * + If omOpaque is specified, the alpha information of src is ignored, and src is always considered completely opaque. In this case, if face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear for the type argument.
	 *
	 * @param face Specifies the drawing method.
	 *
	 * + If dfAlpha is specified, the image is regarded as an image with an alpha channel and drawn.
	 * + If dfAddAlpha is specified, the image is regarded as an image with an additive alpha channel and drawn.
	 * + If dfOpaque is specified, the image is regarded as completely opaque.
	 *
	 * @param opa Specifies the opacity of the overlay (0 to 255).
	 * @param type Specifies the type of affine transformation.
	 *
	 * + stNearest     : Nearest neighbor method is used
	 * + stFastLinear  : Low-precision linear interpolation is used (partially implemented)
	 * + stLinear      : Linear interpolation is used (not implemented)
	 * + stCubic       : 3D interpolation is used (not implemented)
	 *
	 * The speed is fastest in the order of stNearest > stFastLinear > stLinear > stCubic, but the image quality is lower as the speed is faster.
	 * For stFastLinear, stLinear, and stCubic, stRefNoClip can be additionally specified by bitwise OR, and in this case, it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize colors.
	 * If this is not specified, even if there is a margin around the transfer source bitmap, the outside of the transfer source bitmap will not be referenced (the color outside the range is regarded as the color of the pixel within the range closest to it).
	 * @param hda Specifies whether to protect the alpha channel.
	 * @description Performs arithmetic compositing while performing affine transformation on the specified rectangle of the overlay source Bitmap to the overlay destination.
	 */
	function operateAffine( dst, src, A, B, C, D, E, F, srcrect=null, cliprect=null, affine, mode=omAlpha, face=dfAlpha, opa=255, type=stNearest, hda=false);

	/**
	 * Rectangle arithmetic composition
	 *
	 * @param dst Specifies the Bitmap object of the overlay destination.
	 * @param dleft Specifies the left end position of the rectangle of the operation destination in pixel units (in the image position of the operation destination Bitmap).
	 * @param dtop Specifies the upper end position of the rectangle of the operation destination in pixel units (in the image position of the operation destination Bitmap).
	 * @param src Specifies the Bitmap object of the operation source. The entire area is targeted when unspecified.
	 * @param srcrect Specifies the rectangle to be operated on as a Rect object in pixel units (in the image position of the operation source Bitmap).
	 * The entire area is targeted when unspecified.
	 * @param cliprect Specifies the clipping rectangle as a Rect object (in the image position of the overlay destination Bitmap).
	 * No clipping is performed when unspecified.
	 * @param mode Specifies the operation mode.
	 *
	 * + If omPsNormal is specified, Photoshop-compatible alpha compositing is performed.
	 * + If omPsAdditive is specified, Photoshop-compatible dodge (linear) compositing is performed.
	 * + If omPsSubtractive is specified, Photoshop-compatible burn (linear) compositing is performed.
	 * + If omPsMultiplicative is specified, Photoshop-compatible multiply compositing is performed.
	 * + If omPsScreen is specified, Photoshop-compatible screen compositing is performed.
	 * + If omPsOverlay is specified, Photoshop-compatible overlay compositing is performed.
	 * + If omPsHardLight is specified, Photoshop-compatible hard light compositing is performed.
	 * + If omPsSoftLight is specified, Photoshop-compatible soft light compositing is performed.
	 * + If omPsColorDodge is specified, Photoshop-compatible color dodge compositing is performed.
	 * + If omPsColorDodge5 is specified, color dodge compositing compatible with Photoshop version 5.x and earlier is performed.
	 * + If omPsColorBurn is specified, Photoshop-compatible color burn compositing is performed.
	 * + If omPsLighten is specified, Photoshop-compatible compare (light) compositing is performed.
	 * + If omPsDarken is specified, Photoshop-compatible compare (dark) compositing is performed.
	 * + If omPsDifference is specified, Photoshop-compatible absolute difference compositing is performed.
	 * + If omPsDifference5 is specified, absolute difference compositing compatible with Photoshop version 5.x and earlier is performed.
	 * + If omPsExclusion is specified, Photoshop-compatible exclusion compositing is performed.
	 * + If omAdditive is specified, additive compositing is performed.
	 * + If omSubtractive is specified, subtractive compositing is performed.
	 * + If omMultiplicative is specified, multiplicative compositing is performed.
	 * + If omDodge is specified, dodge compositing is performed.
	 * + If omDarken is specified, compare (dark) compositing is performed.
	 * + If omLighten is specified, compare (light) compositing is performed.
	 * + If omScreen is specified, screen multiplication compositing is performed.
	 * + If omAlpha is specified, alpha compositing is performed.
	 * + If omAddAlpha is specified, additive alpha compositing is performed.
	 * + If omOpaque is specified, the alpha information of src is ignored, and src is always considered completely opaque.
	 * @param face Specifies the drawing method.
	 *
	 * + If dfAlpha is specified, the image is regarded as an image with an alpha channel and drawn.
	 * + If dfAddAlpha is specified, the image is regarded as an image with an additive alpha channel and drawn.
	 * + If dfOpaque is specified, the image is regarded as completely opaque.
	 *
	 * @param opa Specifies the intensity of the operation (0 to 255).
	 * @param hda Specifies whether to protect the alpha channel.
	 * @description Performs arithmetic compositing of the specified rectangle part of the operation source Bitmap to the specified position of the operation destination Bitmap in the specified mode.
	 */
	function operateRect( dst, dleft, dtop, src, srcrect=null, cliprect=null, mode=omAuto, face=dfAlpha, opa=255, hda=false);

	/**
	 * Enlargement/reduction arithmetic composition
	 *
	 * @param dst Specifies the Bitmap object of the overlay destination.
	 * @param src Specifies the Bitmap object of the overlay source.
	 * @param dstrect Specifies the rectangle of the overlay destination as a Rect object in pixel units (in the image position of the overlay destination Bitmap).
	 * The entire area is targeted when unspecified.
	 * @param srcrect Specifies the rectangle to be overlaid as a Rect object in pixel units (in the image position of the overlay source Bitmap).
	 * The entire area is targeted when unspecified.
	 * @param cliprect Specifies the clipping rectangle as a Rect object (in the image position of the overlay destination Bitmap).
	 * No clipping is performed when unspecified.
	 * @param mode Specifies the operation mode.
	 *
	 * + If omPsNormal is specified, Photoshop-compatible alpha compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsAdditive is specified, Photoshop-compatible dodge (linear) compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsSubtractive is specified, Photoshop-compatible burn (linear) compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsMultiplicative is specified, Photoshop-compatible multiply compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsScreen is specified, Photoshop-compatible screen compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsOverlay is specified, Photoshop-compatible overlay compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsHardLight is specified, Photoshop-compatible hard light compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsSoftLight is specified, Photoshop-compatible soft light compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsColorDodge is specified, Photoshop-compatible color dodge compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsColorDodge5 is specified, color dodge compositing compatible with Photoshop version 5.x and earlier is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsColorBurn is specified, Photoshop-compatible color burn compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsLighten is specified, Photoshop-compatible compare (light) compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsDarken is specified, Photoshop-compatible compare (dark) compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsDifference is specified, Photoshop-compatible absolute difference compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsDifference5 is specified, absolute difference compositing compatible with Photoshop version 5.x and earlier is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omPsExclusion is specified, Photoshop-compatible exclusion compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omAdditive is specified, additive compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omSubtractive is specified, subtractive compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omMultiplicative is specified, multiplicative compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omDodge is specified, dodge compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omDarken is specified, compare (dark) compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omLighten is specified, compare (light) compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omScreen is specified, screen multiplication compositing is performed (implemented with other than stNearest and stFastLinear after 1.3).
	 * + If omAlpha is specified, alpha compositing is performed. If omAddAlpha is specified, additive alpha compositing is performed. In this case, if face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear for the type argument.
	 * + If omOpaque is specified, the alpha information of src is ignored, and src is always considered completely opaque. In this case, if face is dfOpaque and hda is false, linear interpolation is possible by specifying stFastLinear for the type argument.
	 *
	 * @param face Specifies the drawing method.
	 *
	 * + If dfAlpha is specified, the image is regarded as an image with an alpha channel and drawn.
	 * + If dfAddAlpha is specified, the image is regarded as an image with an additive alpha channel and drawn.
	 * + If dfOpaque is specified, the image is regarded as completely opaque.
	 *
	 * @param opa Specifies the intensity of the operation (0 to 255).
	 * @param type Specifies the type of scaling.
	 *
	 * + stNearest           : Nearest neighbor method is used
	 * + stFastLinear        : Low-precision linear interpolation is used (partially implemented)
	 * + stSemiFastLinear    : Fixed-point linear interpolation is used (after 1.3)
	 * + stLinear            : Linear interpolation is used (implementation changed after 1.3)
	 * + stFastCubic         : Fixed-point 3D interpolation is used (after 1.3)
	 * + stCubic             : 3D interpolation is used (implementation changed after 1.3)
	 * + stFastLanczos2      : Fixed-point Lanczos interpolation with a range of 4x4 is used (after 1.3)
	 * + stLanczos2          : Lanczos interpolation with a range of 4x4 is used (after 1.3)
	 * + stFastLanczos3      : Fixed-point Lanczos interpolation with a range of 6x6 is used (after 1.3)
	 * + stLanczos3          : Lanczos interpolation with a range of 6x6 is used (after 1.3)
	 * + stFastSpline16      : Fixed-point spline interpolation 4x4 is used (after 1.3)
	 * + stSpline16          : Spline interpolation 4x4 is used (after 1.3)
	 * + stFastSpline36      : Fixed-point spline interpolation 6x6 is used (after 1.3)
	 * + stSpline36          : Spline interpolation 6x6 is used (after 1.3)
	 * + stFastAreaAvg       : Fixed-point area average reduction is used. Enlargement is not possible (after 1.3)
	 * + stAreaAvg           : Area average reduction is used. Enlargement is not possible (after 1.3)
	 * + stFastGaussian      : Fixed-point Gaussian interpolation 4x4 is used (after 1.3)
	 * + stGaussian          : Gaussian interpolation 4x4 is used (after 1.3)
	 * + stFastBlackmanSinc  : Fixed-point Blackman-Sinc interpolation 8x8 is used (after 1.3)
	 * + stBlackmanSinc      : Blackman-Sinc interpolation 8x8 is used (after 1.3)
	 *
	 * The speed is fastest in the order of stNearest > stFastLinear > stLinear > stCubic, but the image quality is lower as the speed is faster.
	 * Interpolation methods after stCubic are of sufficiently high image quality and can be said to be a matter of preference.
	 * However, Gaussian interpolation results in a blurred image quality.
	 * The difference between stFastLinear and other linear interpolation (stSemiFastLinear and stLinear) is significant during reduction.
	 * stFastLinear always refers to the surrounding 4 pixels, whereas stSemiFastLinear and stLinear refer to a range where the influence range at the time of equal magnification is 4 pixels during reduction, that is, a wider range of pixels, resulting in higher image quality (algorithmically, it is the original linear interpolation).
	 * For stFastLinear, stRefNoClip can be additionally specified by bitwise OR, and in this case, it is allowed to refer to the outside of the area of the bitmap to be copied and synthesize colors.
	 * If this is not specified, even if there is a margin around the transfer source bitmap, the outside of the transfer source bitmap will not be referenced (the color outside the range is regarded as the color of the pixel within the range closest to it).
	 * @param hda Specifies whether to protect the alpha channel.
	 * @param option Added after 1.3. Sharpness during 3D interpolation.
	 * It has no meaning for other interpolation methods at this time.
	 * Increasing the sharpness value in the positive direction will blur the image, and increasing it in the negative direction will sharpen the image.
	 * @description Performs arithmetic compositing of the specified rectangle of the overlay source Bitmap to the rectangle of the overlay destination Bitmap.
	 * If the sizes of the overlay source rectangle and the overlay destination rectangle are different, enlargement or reduction is performed.
	 */
	function operateStretch( dst, src, dstrect=null, srcrect=null, cliprect=null, mode=omAuto, face=dfAlpha, opa=255, type=stNearest, hda=false, option=-1.0);

	/**
	 * Horizontal flip
	 *
	 * @param bmp Specifies the Bitmap object to be flipped.
	 * @param rect Specifies the area to be flipped as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @description Performs horizontal flipping of the image.
	 */
	function flipLR( bmp, rect=null);

	/**
	 * Vertical flip
	 *
	 * @param bmp Specifies the Bitmap object to be flipped.
	 * @param rect Specifies the area to be flipped as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @description Performs vertical flipping of the image.
	 */
	function flipUD( bmp, rect=null);

	/**
	 * Gamma correction
	 *
	 * @param bmp Specifies the Bitmap object to be gamma corrected.
	 * @param rgamma Specifies the gamma value of the red component (0.0 to 1.0 to 9.0).
	 * @param rfloor Specifies the output minimum value of the red component (0 to 255).
	 * @param rceil Specifies the output maximum value of the red component (0 to 255).
	 * @param ggamma Specifies the gamma value of the green component (0.0 to 1.0 to 9.0).
	 * @param gfloor Specifies the output minimum value of the green component (0 to 255).
	 * @param gceil Specifies the output maximum value of the green component (0 to 255).
	 * @param bgamma Specifies the gamma value of the blue component (0.0 to 1.0 to 9.0).
	 * @param bfloor Specifies the output minimum value of the blue component (0 to 255).
	 * @param bceil Specifies the output maximum value of the blue component (0 to 255).
	 * @param cliprect Specifies the clipping area as a Rect object (in the image position of the Bitmap). The entire area is targeted when unspecified.
	 * @param isaddalpha Specifies whether it is an additive compositing alpha format.
	 * @description Executes gamma correction on the image.
	 * If 1.0 is specified for the gamma value, the gamma curve becomes a straight line.
	 * The output minimum value and output maximum value specify the minimum and maximum values of the luminance of each component.
	 * Setting a value lower than the minimum value for the maximum value can invert the image.
	 * If isaddalpha is true, this method uses a special gamma correction routine for additive alpha compositing.
	 * This routine performs gamma correction on the component corresponding to alpha compositing in additive alpha compositing, but does not perform gamma correction on the component corresponding to additive compositing.
	 */
	function adjustGamma( bmp, rgamma=1.0, rfloor=0, rceil=255, ggamma=1.0, gfloor=0, gceil=255, bgamma=1.0, bfloor=0, bceil=255, cliprect=null, isaddalpha=false);

	/**
	 * Apply a rectangular blur
	 *
	 * @param bmp Specifies the Bitmap object to apply the rectangular blur to.
	 * @param xblur Specifies the range of the horizontal blur.
	 * @param yblur Specifies the range of the vertical blur.
	 * @param cliprect Specifies the clipping area as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @param isalpha Specifies whether to have an alpha channel.
	 * @description Applies a blur.
	 * The algorithm is "rectangular blur" (box blur).
	 * Rectangular blur is the average value of the luminance of pixels in the "range" expressed by the two parameters xblur and yblur.
	 * For example, if xblur=10 yblur=2, the average of the luminance of pixels in the rectangular range of -10 to 10 in the horizontal direction and -2 to 2 in the vertical direction, centered on the target pixel, is taken, and that becomes the final luminance of that pixel.
	 * The area of the range can be calculated by (xblur×2+1) × (yblur×2+1).
	 * In the current version, if this area is less than 256, an algorithm that is faster than when the area is 256 or more is adopted.
	 * If isalpha is true, a special algorithm for alpha compositing is used, so it will be a little slower.
	 * If false, the algorithm will be faster.
	 */
	function doBoxBlur( bmp, xblur=1, yblur=1, cliprect=null, isalpha=true);

	/**
	 * Grayscale conversion
	 *
	 * @param bmp Specifies the Bitmap object to be converted to grayscale.
	 * @param cliprect Specifies the clipping area as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @description Converts the image to grayscale.
	 */
	function doGrayScale( bmp, cliprect=null);

	/**
	 * Rectangle semi-transparent fill
	 *
	 * @param bmp Specifies the Bitmap object to be filled.
	 * @param value Specifies the color or value to fill.
	 * The meaning of this value changes depending on the value of the face argument.
	 *
	 * + dfAlpha     : Specify the color in 0xRRGGBB format
	 * + dfAddAlpha  : Specify the color in 0xRRGGBB format
	 * + dfOpaque    : Specify the color in 0xRRGGBB format
	 * + dfMask      : Specify the mask (opacity) value (0 to 255)
	 *
	 * If dfOpaque is specified, the mask information is ignored.
	 * Also, if dfMask is specified, the color information remains as is.
	 * This argument is ignored if face is dfAlpha and opa is negative.
	 * @param opa Specifies the opacity to fill ( -255 to 0 to 255 ).
	 * This argument is ignored if the value of face is dfMask or dfProvince (always completely opaque).
	 * Specifying a negative number is valid only when face is dfAlpha, in which case the value argument is ignored and opacity is removed from the image (specifying -255 makes the rectangle completely transparent).
	 * @param rect Specifies the rectangle to be filled as a Rect object in pixel units (in the image position).
	 * The entire area is targeted when unspecified.
	 * @param face Specifies the drawing method.
	 *
	 * + If dfAlpha is specified, the image is regarded as an image with an alpha channel and drawn.
	 * + If dfAddAlpha is specified, the image is regarded as an image with an additive alpha channel and drawn.
	 * + If dfOpaque is specified, the image is regarded as completely opaque.
	 *
	 * @param cliprect Specifies the clipping area as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @description Fills the rectangle of the specified Bitmap image in the specified way.
	 * Unlike ImageFunction.fillRect, you can specify the transparency and fill it semi-transparently.
	 */
	function colorRect( bmp, value, opa=255, rect=null, face=dfAlpha, cliprect=null);

	/**
	 * Draw text
	 *
	 * @param bmp Specifies the Bitmap object to draw text on.
	 * @param font Specifies the font to draw with a Font object.
	 * @param x Specifies the x coordinate in pixel units of the origin to start drawing the text (in the image position).
	 * @param y Specifies the y coordinate in pixel units of the origin to start drawing the text (in the image position).
	 * @param text Specifies the text to draw.
	 * @param color Specifies the color of the text to draw in 0xRRGGBB format.
	 * @param opa Specifies the opacity of the text to draw ( -255 to 0 to 255 ).
	 * Specifying a negative number is valid only when face is dfAlpha, in which case opacity is removed from the shape of the text (the smaller the value, the greater the effect).
	 * @param aa Specifies whether to perform anti-aliasing.
	 * Anti-aliasing is performed if true is specified.
	 * It is not performed if false is specified.
	 * @param face Specifies the drawing method.
	 *
	 * + If dfAlpha is specified, the image is regarded as an image with an alpha channel and drawn.
	 * + If dfAddAlpha is specified, the image is regarded as an image with an additive alpha channel and drawn.
	 * + If dfOpaque is specified, the image is regarded as completely opaque.
	 *
	 * @param shadowlevel Specifies the opacity of the shadow.
	 * The appropriate value varies depending on the value of the shadowwidth argument.
	 * If 0 is specified, the shadow is not drawn.
	 * @param shadowcolor Specifies the color of the shadow in 0xRRGGBB format.
	 * @param shadowwidth Specifies the width (blur) of the shadow.
	 * 0 is the sharpest (no blur), and increasing the value can blur the shadow.
	 * @param shadowofsx Specifies the value of the x coordinate of the shadow position in pixel units.
	 * If 0 is specified, the shadow is drawn directly below.
	 * @param shadowofsy Specifies the value of the y coordinate of the shadow position in pixel units.
	 * If 0 is specified, the shadow is drawn directly below.
	 * @param hda Specifies whether to protect the alpha channel.
	 * @param cliprect Specifies the clipping area as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @return Drawing area (Rect object)
	 * @description Draws text on the Bitmap.
	 * If dfOpaque is specified for face, whether the mask of the drawing destination is destroyed or protected depends on hda.
	 */
	function drawText( bmp, font, x, y, text, color, opa=255, aa=true, face=dfAlpha, shadowlevel=0, shadowcolor=0x000000, shadowwidth=0, shadowofsx=0, shadowofsy=0, hda=false, cliprect=null);

	/**
	 * Draw text
	 *
	 * @param bmp Specifies the Bitmap object to draw text on.
	 * @param x Specifies the x coordinate in pixel units of the origin to start drawing the text (in the image position).
	 * @param y Specifies the y coordinate in pixel units of the origin to start drawing the text (in the image position).
	 * @param glyph Specifies the glyph to draw.
	 * @param color Specifies the color of the text to draw in 0xRRGGBB format.
	 * @param opa Specifies the opacity of the text to draw ( -255 to 0 to 255 ).
	 * Specifying a negative number is valid only when face is dfAlpha, in which case opacity is removed from the shape of the text (the smaller the value, the greater the effect).
	 * @param aa Specifies whether to perform anti-aliasing.
	 * Anti-aliasing is performed if true is specified.
	 * It is not performed if false is specified.
	 * @param face Specifies the drawing method.
	 *
	 * + If dfAlpha is specified, the image is regarded as an image with an alpha channel and drawn.
	 * + If dfAddAlpha is specified, the image is regarded as an image with an additive alpha channel and drawn.
	 * + If dfOpaque is specified, the image is regarded as completely opaque.
	 *
	 * @param shadowlevel Specifies the opacity of the shadow.
	 * The appropriate value varies depending on the value of the shadowwidth argument.
	 * If 0 is specified, the shadow is not drawn.
	 * @param shadowcolor Specifies the color of the shadow in 0xRRGGBB format.
	 * @param shadowwidth Specifies the width (blur) of the shadow.
	 * 0 is the sharpest (no blur), and increasing the value can blur the shadow.
	 * @param shadowofsx Specifies the value of the x coordinate of the shadow position in pixel units.
	 * If 0 is specified, the shadow is drawn directly below.
	 * @param shadowofsy Specifies the value of the y coordinate of the shadow position in pixel units.
	 * If 0 is specified, the shadow is drawn directly below.
	 * @param hda Specifies whether to protect the alpha channel.
	 * @param cliprect Specifies the clipping area as a Rect object (in the image position of the Bitmap).
	 * The entire area is targeted when unspecified.
	 * @return Drawing area (