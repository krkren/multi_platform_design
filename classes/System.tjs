/**
 * @description The System class is a class for getting and setting information about the KiriKiri main body and the environment in which KiriKiri is running.
 * You cannot create objects from this class.
 */
class System {
	/**
	 * Asynchronous termination of KiriKiri
	 *
	 * @param code Specifies the exit code of the process
	 * @description Terminates KiriKiri.
	 * KiriKiri does not terminate immediately even if this method is called.
	 * It will terminate when control returns to KiriKiri from all event handlers.
	 */
	function terminate( code=0);

	/**
	 * Synchronous termination of KiriKiri
	 *
	 * @param code Specifies the exit code of the process
	 * @description Terminates KiriKiri.
	 * Unlike System.terminate, this method terminates when called.
	 * Therefore, this method does not return.
	 */
	function exit( code=0);

	/**
	 * Adding a Continuous handler
	 *
	 * @param callback Specifies the function to be the handler.
	 * @description Registers a Continuous handler.
	 * A Continuous handler is an event handler that is called "as often as possible".
	 * If there is nothing else to do, KiriKiri will continue to call the Continuous handler.
	 * If other events occur, they will take precedence.
	 * However, if the calling frequency is specified by the -contfreq command line option, it will be followed.
	 */
	function addContinuousHandler( callback);

	/**
	 * Deleting a Continuous handler
	 *
	 * @param callback Specifies the handler function.
	 * @description Deletes a Continuous handler.
	 */
	function removeContinuousHandler( callback);

	/**
	 * Displaying a message
	 *
	 * @param text Specifies the message to display.
	 * @param caption Specifies the string to be the caption of the window.
	 * @description Displays a window to show a message to the user.
	 * The window is displayed modally (that is, other windows cannot be operated while it is displayed).
	 * On Android, it is displayed as a toast, and control is returned immediately.
	 * Also, caption has no meaning.
	 */
	function inform( text, caption="");

	/**
	 * Getting the tick count
	 *
	 * @return Returns the tick count (64-bit integer).
	 * @description The tick count is a number that counts up every 1/1000th of a second.
	 * If you get the tick count at two points in time using this method and take the difference, you can know the time difference between the two points in time.
	 */
	function getTickCount( );

	/**
	 * [Windows*] Getting the key state
	 *
	 * @param code Specifies the virtual key code to get the state of.
	 * @return Returns true if the key is pressed, false if it is not pressed.
	 * @description Gets whether the key corresponding to the key code specified by code is pressed at the time this method is called.
	 * In the case of Android, false is always returned.
	 */
	function getKeyState( code);

	/**
	 * [Windows*] Executing a file/program
	 *
	 * @param target Specifies the file or software to execute.
	 * If a file is specified, the program associated with it will be launched.
	 * @param param Specifies the parameters to pass to the software to be executed.
	 * If you specify a file for the target argument, omit this argument or specify an empty string.
	 * @return Returns true if execution is successful, false if it fails.
	 * @description Executes the file or software specified by target.
	 * Nothing happens on Android.
	 */
	function shellExecute( target, param="");

	/**
	 * [Windows+] Reading the registry
	 *
	 * @param key Specifies the registry key to read.
	 * @return Returns the value of the registry if execution is successful, void if it fails.
	 * @description Reads the Windows registry specified by key.
	 * The registry key can start with the following root key names:
	 * HKEY_CLASSES_ROOT, HKEY_CURRENT_CONFIG, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_DYN_DATA
	 * For example, you can specify the following string for key:
	 * HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\hoge\installdir
	 * You can only read numbers and single strings.
	 * In the case of numbers, an integer type result is returned, and in the case of strings, a string type result is returned.
	 */
	function readRegValue( key);

	/**
	 * Getting command line options
	 *
	 * @param name Specifies the command line option name to get.
	 * Be sure to put a '-'(hyphen) at the beginning (e.g. '-nosplash').
	 * @return Returns the value of the command line option if it is specified, void if it is not specified.
	 * @description Command line options must be passed to KiriKiri in the form -name=value or -name.
	 * In the former case, value is returned as the value, and in the former case, 'yes' is returned as the value.
	 * @see System.setArgument
	 */
	function getArgument( name);

	/**
	 * Setting command line options
	 *
	 * @param name Specifies the command line option name to set. Be sure to put a '-'(hyphen) at the beginning (e.g. '-contfreq').
	 * @param value Specifies the value to set. (e.g. '60').
	 * @description Dynamically sets command line options.
	 * Not all command line options can be set.
	 * See Command Line Options for settable command line options.
	 * Do not change options that are not marked as dynamically changeable here.
	 * This method does not check whether the option can be changed dynamically, whether the option exists, or whether the value is valid.
	 * Be careful when setting values.
	 * @see System.getArgument
	 */
	function setArgument( name, value );

	/**
	 * Getting the actual color of a color constant
	 *
	 * @param color Specifies a color constant (see Color Constant List).
	 * If you specify a normal 0xRRGGBB format color, the value is returned as is.
	 * @return Returns the actual color represented by the specified color constant in 0xRRGGBB format.
	 * @description Converts a color constant to an actual color and returns it in 0xRRGGBB format.
	 */
	function toActualColor( color );

	/**
	 * [Windows+] Checking for double startup
	 *
	 * @param key Specifies the key string to use for the check. If another running KiriKiri specifies the same key string for this method, false is returned.
	 * Basically, you should only use characters that are the same as the naming rules for TJS variables for the key string.
	 * The key string must be sufficiently unique.
	 * @return Returns false if KiriKiri with the same key string is already running, true otherwise.
	 * @description Returns false if another KiriKiri with the same key string is running, true otherwise.
	 * Used to prevent double startup.
	 */
	function createAppLock( key );

	/**
	 * Generating a UUID string
	 *
	 * @return Returns the generated UUID string in the format "e8b2a2b5-5ceb-4f75-a08b-1f1bdfdca4f1" (each alphanumeric character excluding hyphens is a hexadecimal number).
	 * @description Generates and returns a UUID string. This method generates a 128-bit UUID (universal unique identifier) generated from a random bit string.
	 * The UUID generation algorithm implemented in KiriKiri generates random bit strings by picking up environmental noise to some extent, but it is not recommended to use it for applications that require a high level of security.
	 * However, it can be considered that it "very, very highly unlikely" to overlap with other UUIDs.
	 */
	function createUUID();

	/**
	 * Changing message assignment
	 *
	 * @param id Specifies the message ID to assign.
	 * @param msg Specifies the message to assign to the ID specified by id.
	 * @return Returns true if the ID exists and the message assignment is successful, false otherwise.
	 * @description Changes the message assignment. You can change the messages built into KiriKiri to other messages with this method.
	 * Normally, it is described in the message map file (see How to Start).
	 * To get a list of configurable IDs and the messages currently assigned to them, execute "Creating a Message Map File".
	 */
	function assignMessage( id, msg);

	/**
	 * Compacting memory
	 *
	 * @param level Specifies the level. If you specify clIdle, the same process as the compaction performed when the system is idle (when the system is relatively inactive) is performed.
	 * In the current version, TJS2 garbage collection is performed.
	 *
	 * + If you specify clDeactivate, the same process as the compaction performed when KiriKiri becomes inactive (when another application becomes active) is performed. In the current version, the temporary image buffer for layer calculation, the layer cache, the segment (storage fragment) cache of the XP3 archive, and the automatic search path cache are cleared.
	 * + If you specify clMinimize, the same process as the compaction performed when KiriKiri is minimized is performed. In the current version, the drawing character cache and the image cache are cleared.
	 * + If you specify clAll, all of the above compaction is performed.
	 *
	 * The compaction level increases in the order of clIdle < clDeactivate < clMinimize < clAll.
	 * If you specify a higher level, the compaction performed at the lower level is also performed.
	 * For example, if you execute clDeactivate, the process at clIdle is also executed.
	 * If the argument is omitted, it is assumed that clAll is specified.
	 * @description Compresses memory.
	 * Compaction is a process that releases unused memory and various cache memory to reduce memory usage.
	 * KiriKiri does this automatically, so you don't normally need to worry about it, but you can use this method if you want to force it to be done by the program.
	 */
	function doCompact( level=clAll);

	/**
	 * Loading images into the cache
	 *
	 * @param storages Pass the image storage names you want to put in the cache as an array (Array class object).
	 * The ones written earlier have higher priority.
	 * KiriKiri manages the cache using the string specified as the first argument of Layer.loadImages as is as the key, so to make the cache meaningful, the image storage name specified here must be the same as the one specified as the first argument of Layer.loadImages.
	 * @param limitbytes Specifies the limit value of the cache capacity to be used by calling this method in bytes.
	 * If you specify 0, all the cache is used. If you specify a positive number, it will try to use the cache up to that number of bytes.
	 * If you specify a negative number, the number obtained by adding that number to the current cache limit value (System.graphicCacheLimit) (however, since you are adding a "negative number", it is actually subtraction) is used as the limit value.
	 * If the resulting limit value is 0 or negative, this method will terminate without doing anything.
	 * For example, if you specify -2*1024*1024, it is assumed that the number obtained by subtracting 2MB from the current cache limit value is specified.
	 * This is useful when you want to leave some free space in the remaining cache capacity.
	 * @param timeout Specifies the timeout (time limit) in ms. If you specify 0, there is no limit.
	 * This method stops loading images and returns after the time specified by this argument has elapsed.
	 * However, even if a timeout occurs while loading an image, it will not return until the loading of that image is complete.
	 * @description This method attempts to put the specified image into the cache.
	 * However, although this method tries to put the image into the cache, there is no guarantee that the image will actually be in the cache.
	 * Image loading is interrupted when the image cache limit is exceeded or a timeout occurs.
	 * Of the images specified in the storages argument, the ones written earlier have a higher possibility of being put into the cache (they have higher priority).
	 * If the specified image is already in the cache, it only raises the rank of survival in the cache.
	 * This method ignores all errors during image loading.
	 * In the current version, the images that can be put into the cache with this method are images that can normally be loaded with Layer.loadImages and that do not specify a color key (images with alpha channels are no problem).
	 * Universal transition rule images and region images will be loaded, but they will not become valid data as a cache (the loaded data will be wasted), so do not specify them.
	 * See System.graphicCacheLimit for the number of bytes that an image uses in the cache.
	 */
	function touchImages( storages, limitbytes=0, timeout=0);

	/**
	 * [Windows+] Displaying the about dialog
	 *
	 * @description Displays the about dialog.
	 */
	function showVersion();

	/**
	 * [Windows+] Heap information dump
	 *
	 * @description Outputs heap information to the console.
	 */
	function dumpHeap();

	/**
	 * Causes a null pointer access
	 * @description Do not call.
	 */
	function nullpo();
	/**
	 * Version string
	 *
	 * @description You can get the version string of the KiriKiri main body.
	 * The version string is in the following format: 1.0.0.1
	 */
	 property versionString {
		 getter() { return value; }
	}
	/**
	 * Version information string
	 *
	 * @description You can get the version information string of the KiriKiri main body.
	 * The version information string is in a longer format than System.versionString, and is as follows:
	 * KiriKiri Z Execution Core/1.0.0.0 (Compiled on Dec 16 2013 23:15:27) TJS2/2.4.28 Copyright (C) 1997-2013 W.Dee and contributors All rights reserved.
	 */
	 property versionInformation {
		 getter() { return value; }
	}
	/**
	 * Whether event delivery is stopped
	 *
	 * @description Becomes true when KiriKiri's event delivery is stopped.
	 * You can also set the value.
	 * When event delivery is stopped, events on KiriKiri will not occur or will be postponed (the behavior differs depending on the type of event).
	 */
	 property eventDisabled {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Image cache limit
	 *
	 * @description Represents the KiriKiri image cache limit in bytes.
	 * You can also set the value.
	 * If you specify gcsAuto, the value is automatically set according to the amount of memory installed in the machine.
	 * Rule images and region images consume the number of bytes represented by width x height.
	 * Other images consume the number of bytes represented by width x height x 4.
	 */
	 property graphicCacheLimit {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Platform name
	 *
	 * @description Represents the platform name on which KiriKiri is running.
	 * In the case of Windows, it is 'Win32' when the OS is a 32bit version, and 'Win64' when it is a 64bit version.
	 * In the case of Android, it is Android.
	 */
	 property platformName {
		 getter() { return value; }
	}
	/**
	 * OS name
	 *
	 * @description Represents the name of the OS on which KiriKiri is running.
	 */
	 property osName {
		 getter() { return value; }
	}
	/**
	 * Path to the folder where the KiriKiri main body is located
	 *
	 * @description Represents the path where the KiriKiri main body is installed.
	 * The path name is expressed in a unified storage name.
	 * On Android, it is the folder name of packageCodePath.
	 * @see System.appDataPath
	 * @see System.personalPath
	 * @see System.packageCodePath
	 */
	 property exePath {
		 getter() { return value; }
	}
	/**
	 * Path to My Documents
	 *
	 * @description Represents the path to the user's My Documents.
	 * In the case of Windows, the folder represented by Personal in HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders in the registry is returned.
	 * This usually refers to the "My Documents" folder.
	 * If this folder does not exist, it returns the same folder as System.exePath.
	 * @see System.appDataPath
	 * @see System.exePath
	 */
	 property personalPath {
		 getter() { return value; }
	}
	/**
	 * Path to the user's home directory
	 *
	 * @description Represents the path to the user's home directory.
	 * In the case of Windows, the folder represented by AppData in HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders in the registry is returned.
	 * If this folder does not exist, it returns the same folder as System.exePath.
	 * This is usually as follows:
	 * In the case of XP, C:\Documents and Settings\<username>\Application Data\ (the C: part differs depending on the environment)
	 * In the case of Vista, 7, 8, C:\Users\<username>\AppData\Roaming (the C: part differs depending on the environment) If the registry key (see above) cannot be read for some reason, it will be the folder where the KiriKiri executable file is located (System.exePath)
	 * On Android, it is the same as filesDir.
	 * @see System.exePath
	 * @see System.personalPath
	 * @see System.filesDir
	 */
	 property appDataPath {
		 getter() { return value; }
	}
	/**
	 * Path to the data storage location
	 *
	 * @description Represents the directory specified by the -datapath command line option.
	 * By default, all logs etc. are output here.
	 * It is recommended that user scripts save data here.
	 * On Android, externalFilesDir is set.
	 * @see System.externalFilesDir
	 */
	 property dataPath {
		 getter() { return value; }
	}
	/**
	 * Path to the KiriKiri main body
	 *
	 * @description Represents the path name to the KiriKiri main body.
	 * The path name is expressed in a unified storage name.
	 * On Android, it is the same as packageCodePath.
	 * @see System.packageCodePath
	 */
	 property exeName {
		 getter() { return value; }
	}
	/**
	 * Title
	 *
	 * @description Represents the title of the main window as a string.
	 * You can also set the value.
	 * @see Window.caption
	 * On Android, it is set to the title of the Activity, but it is not displayed because it is hidden in full screen mode.
	 */
	 property title {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Screen width
	 *
	 * @description Represents the horizontal size of the screen size (screen resolution) in pixels.
	 * The value is for the display where the main window is located.
	 * If there is no main window, the primary display is targeted.
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property screenWidth {
		 getter() { return value; }
	}
	/**
	 * Screen height
	 *
	 * @description Represents the vertical size of the screen size (screen resolution) in pixels.
	 * The value is for the display where the main window is located.
	 * If there is no main window, the primary display is targeted.
	 * @see System.screenWidth
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property screenHeight {
		 getter() { return value; }
	}
	/**
	 * Desktop left edge position
	 *
	 * @description Represents the left edge position of the desktop (the area where windows can be displayed) in pixels.
	 * The value is for the display where the main window is located.
	 * If there is no main window, the primary display is targeted.
	 * Always 0 on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property desktopLeft {
		 getter() { return value; }
	}
	/**
	 * Desktop top edge position
	 *
	 * @description Represents the top edge position of the desktop (the area where windows can be displayed) in pixels.
	 * The value is for the display where the main window is located.
	 * If there is no main window, the primary display is targeted.
	 * Always 0 on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopWidth
	 * @see System.desktopHeight
	 */
	 property desktopTop {
		 getter() { return value; }
	}
	/**
	 * Desktop width
	 *
	 * @description Represents the width of the desktop (the area where windows can be displayed) in pixels.
	 * The value is for the display where the main window is located.
	 * If there is no main window, the primary display is targeted.
	 * Screen width on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopHeight
	 */
	 property desktopWidth {
		 getter() { return value; }
	}
	/**
	 * Desktop height
	 *
	 * @description Represents the height of the desktop (the area where windows can be displayed) in pixels.
	 * The value is for the display where the main window is located.
	 * If there is no main window, the primary display is targeted.
	 * Screen width height on Android.
	 * @see System.screenWidth
	 * @see System.screenHeight
	 * @see System.desktopLeft
	 * @see System.desktopTop
	 * @see System.desktopWidth
	 */
	 property desktopHeight {
		 getter() { return value; }
	}
	/**
	 * [Windows] Whether to exit when the main window closes
	 *
	 * @description Represents whether to exit when the main window (the instance of the Window class created first) closes.
	 * You can also set the value.
	 * The default is true.
	 * If the main window closes and no other debug-related windows are displayed, KiriKiri may remain in the system without exiting and become uncontrollable (you may have no choice but to terminate the process from the task manager).
	 * 	
	 */
	 property exitOnWindowClose {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Handler function for uncaught exceptions
	 *
	 * @description Represents a function that handles uncaught exceptions (exceptions that are passed to the KiriKiri main body without being caught anywhere).
	 * If you specify null, the default behavior will be used.
	 * The default behavior is to stop the delivery of asynchronous events (set System.eventDisabled to true), start outputting logs to a file (call Debug.logAsError), display a dialog box notifying the error, and show the location in the script editor.
	 * The handler function takes one argument, which is the exception object.
	 * If the handler function is not specified, or if the handler function is null, or if the handler function returns false, the default behavior is performed.
	 * If the handler function returns true, the above default behavior is not performed.
	 * Consider the possibility that asynchronous events may occur while the handler function is running.
	 * If the KiriKiri main body can process asynchronous events, an unexpected exception may occur again while the exception handler is running.
	 * To avoid this, normally, when doing something that waits in the handler function (when KiriKiri has a chance to process asynchronous events), stop the occurrence of asynchronous events.
	 * Example:
	 *
	 * ```
	 * System.exceptionHandler = function (e){
	 *    // This function is called when an exception that is not caught anywhere is caught by the system. e is the exception object.
	 *    if(e instanceof "ConductorException"){
	 *        // In the case of an exception thrown by the conductor
	 *        Debug.logAsError();
	 *        // Start writing logs to a file, etc.
	 *        var event_disabled = System.eventDisabled;System.eventDisabled = true;
	 *        // If an event occurs while the reason for the error is being displayed, it will be
	 *        // troublesome, so stop the event from occurring once
	 *        System.inform(e.message);
	 *        System.eventDisabled = event_disabled;
	 *        // Return whether to generate the event to its original state
	 *        return true;
	 *        // If you return true, the main body will no longer process the exception
	 *    }else{
	 *        return false;
	 *        // If you return false, normal exception handling will be performed
	 *    }
	 * };
	 * ```
	 * @see System.eventDisabled
	 * @see Debug.logAsError
	 */
	 property exceptionHandler {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * When the application becomes active
	 *
	 * @description Represents an event function that is called when the application becomes active.
	 * If you specify null, the function will not be called.
	 * Unlike normal event handlers, if you want to receive this event, set the function you want to call to this property.
	 * Window.onActivate occurs when each window in the same application becomes active, but this event occurs when the main window becomes active.
	 * Note that this event may occur even if the main window is already active (there is no guarantee that it will occur completely in the order of onActivate -> onDeactivate -> onActivate -> ...).
	 * @see System.onDeactivate
	 * @see Window.onActivate
	 * @see Window.onDeactivate
	 */
	 property onActivate {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * When the application becomes inactive
	 *
	 * @description Represents an event function that is called when the application becomes inactive.
	 * If you specify null, the function will not be called.
	 * Unlike normal event handlers, if you want to receive this event, set the function you want to call to this property.
	 * Window.onDeactivate occurs when each window in the same application becomes inactive, but this event occurs when the main window becomes inactive.
	 * Note that this event may occur even if the main window is already inactive (there is no guarantee that it will occur completely in the order of onActivate -> onDeactivate -> onActivate -> ...).
	 * @see System.onActivate
	 * @see Window.onActivate
	 * @see Window.onDeactivate
	 */
	 property onDeactivate {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Number of threads used for drawing
	 *
	 * @description Represents the number of threads that the KiriKiri layer system uses when drawing.
	 * You can also set the value.
	 * If you specify dtnAuto, the same number of threads as the number of processors recognized by the OS will be automatically allocated.
	 * Setting multiple drawing threads may improve drawing performance in a multi-core environment, but it may also degrade performance.
	 * Good results may be obtained by applying it to processes with large drawing areas, high-load Affine-based processes, and layer composition processes with heavy calculations.
	 * Even if you set it to use multi-threading, if the system determines that the load of the drawing process is light and the effect of multi-threading cannot be obtained, it may not be executed in multi-threading.
	 */
	 property drawThreadNum {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Path to the saved game (since 1.1.0)
	 *
	 * @description Represents the path to the saved game.
	 * This is usually as follows:
	 * C:\Users\<username>\Saved Games
	 */
	 property savedGamesPath {
		 getter() { return value; }
	}
	/**
	 * Whether the KiriKiri main body is 32bit or 64bit (since 1.3.0)
	 *
	 * @description Represents whether the executable binary is 32bit or 64bit with an integer of 32 or 64.
	 * @see System.osBits
	 * @see System.platformName
	 */
	 property exeBits {
		 getter() { return value; }
	}
	/**
	 * Whether the OS is 32bit or 64bit (since 1.3.0)
	 *
	 * @description Represents whether the OS is 32bit or 64bit with an integer of 32 or 64.
	 * @see System.exeBits
	 * @see System.platformName
	 */
	 property osBits {
		 getter() { return value; }
	}
	/**
	 * Determines whether the system is Windows [r]
	 */
	property isWindows;

	/**
	 * Determines whether the system is Android [r]
	 */
	property isAndroid;

	/**
	 * [Android+] Path to the external cache area [r]
	 * @description What is obtained by Context.getExternalCacheDir().
	 */
	property externalCacheDir;
	/**
	 * [Android+] Internal cache area [r]
	 * @description What is obtained by Context.getCacheDir().
	 */
	property cacheDir;
	/**
	 * [Android+] Internal data area [r]
	 * @description What is obtained by Context.getFilesDir().
	 */
	property filesDir;
	/**
	 * [Android+] External data area [r]
	 * @description What is obtained by Context.getExternalFilesDir().
	 */
	property externalFilesDir;
	/**
	 * [Android+] Extended file (OBB format) storage area [r]
	 * @description What is obtained by Context.getObbDir().
	 */
	property obbDir;
	/**
	 * [Android+] App's Shared Object (*.so) file storage area [r]
	 */
	property sharedObjectPath;
	/**
	 * [Android+] App package name [r]
	 */
	property packageName;
	/**
	 * [Android+] App package code path [r]
	 */
	property packageCodePath;
	/**
	 * [Android+] App package resource path [r]
	 */
	property packageResourcePath;
	/**
	 * [Android+] Data area [r]
	 * @description What is obtained by Environment.getDataDirectory().
	 */
	property dataDirectory;
	/**
	 * [Android+] Download cache path [r]
	 * @description What is obtained by Environment.getDownloadCacheDirectory().
	 */
	property downloadCacheDirectory;
	/**
	 * [Android+] External shared area [r]
	 * @description What is obtained by Environment.getExternalStorageDirectory().
	 */
	property externalStorageDirectory;
	/**
	 * [Android+] Music data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC).
	 */
	property externalPublicMusicPath;
	/**
	 * [Android+] Podcast data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PODCASTS).
	 */
	property externalPublicPodcastsPath;
	/**
	 * [Android+] Ringtone data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_RINGTONES).
	 */
	property externalPublicRingtonesPath;
	/**
	 * [Android+] Alarm sound data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_ALARMS).
	 */
	property property externalPublicAlaramsPath;
	/**
	 * [Android+] Notification sound data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_NOTIFICATIONS).
	 */
	property externalPublicNotificationsPath;
	/**
	 * [Android+] Photo data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).
	 */
	property externalPublicPicturesPath;
	/**
	 * [Android+] Video data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES).
	 */
	property externalPublicMoviesPath;
	/**
	 * [Android+] Download path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).
	 */
	property externalPublicDownloadsPath;
	/**
	 * [Android+] DCIM (camera) data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).
	 */
	property externalPublicDCIMPath;
	/**
	 * [Android+] Document data path [r]
	 * @description What is obtained by Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS).
	 */
	property externalPublicDocumentsPath;
	/**
	 * [Android+] Root directory [r]
	 * @description What is obtained by Environment.getRootDirectory().
	 */
	property rootDirectory;
	/**
	 * [Android+] External storage status [r]
	 * @description What is obtained by Environment.getExternalStorageState().
	 * One of the following:
	 *
	 * + "unknown" Unknown state
	 * + "removed" Removed state
	 */
}