/**
 * @description The WaveSoundBuffer class is a class that manages PCM playback.
 * The WaveSoundBuffer class can read and process .sli files created with Loop Tuner.
 * See the Loop Tuner documentation for details.
 */
class WaveSoundBuffer {
	/**
	 * WaveSoundBuffer object construction
	 *
	 * @param owner Specifies the event destination.
	 * @description Constructs a WaveSoundBuffer class object.
	 * When an event occurs, the action method of the object specified by owner is called.
	 * If null is specified for owner, the action method is not called.
	 * Normally, specify a Window class object for owner.
	 */
	function WaveSoundBuffer( owner);

	/**
	 * Status changed
	 *
	 * @param status New status. See the WaveSoundBuffer.status property.
	 * @description Occurs when the playback status (state) changes.
	 */
	event onStatusChanged( status);

	/**
	 * Passed a label
	 *
	 * @param name The name of the label that passed.
	 * @description Occurs when the playback position passes a label.
	 */
	event onLabel( name);

	/**
	 * Fade completed
	 *
	 * @description Occurs when the fade started with the WaveSoundBuffer.fade method ends.
	 */
	event onFadeCompleted( );

	/**
	 * Open media
	 *
	 * @param storage Specifies the storage you want to play.
	 * @description Opens the specified media.
	 * This method does not start playback.
	 * If there is a file name with .sli appended to the specified storage name, it is read as sound loop information.
	 */
	function open( storage);

	/**
	 * Play media
	 *
	 * @description Starts playing the media.
	 */
	function play( );

	/**
	 * Stop media
	 *
	 * @description Stops the media.
	 */
	function stop( );

	/**
	 * Start fade
	 *
	 * @param to Specifies the volume to reach.
	 * See the WaveSoundBuffer.volume property for specifying the volume.
	 * @param time Specifies the time to fade in ms.
	 * @param delay Specifies the waiting time until the fade starts in ms.
	 * @description Starts a fade (continuous volume change).
	 */
	function fade( to, time, delay=0);

	/**
	 * Stop fade
	 *
	 * @description Forcefully stops the fade started with the WaveSoundBuffer.fade method.
	 * The volume remains at the time of stopping.
	 */
	function stopFade( );

	/**
	 * DirectSound release
	 *
	 * @description Releases DirectSound.
	 * All WaveSoundBuffer class objects will be stopped.
	 * This method is used to release DirectSound in environments where DirectSound and WaveMapper (MCI, etc.) cannot be played at the same time.
	 * This method exists only on the WaveSoundBuffer class (this method does not exist on objects created from WaveSoundBuffer).
	 * When using, use WaveSoundBuffer.freeDirectSound();
	 */
	function freeDirectSound( );

	/**
	 * Get visualization data
	 *
	 * @param buffer Specifies the buffer to write output data to.
	 * The buffer is an array of 16bit signed integers, and must have enough elements (numsamples * channels or more) to write the samples specified by the numsamples and channels arguments.
	 * If a value other than 1 is specified for channels, the samples for each channel are interleaved (in the order Right Left Right Left ... if stereo).
	 * You need to specify a pointer to the first element of the array, but pass it cast to an integer type.
	 * @param numsamples Specifies the number of samples to get.
	 * @param channel Specifies the number of channels to get.
	 * If you specify 1, you can get data that has been downmixed to 1 channel in the case of mono, and otherwise.
	 * If you specify a number other than 1, you must specify the same number of channels as the sound being played.
	 * In this case, you can get the data as is.
	 * @param ahead Specifies the number of samples to look ahead.
	 * You can get samples from samples that are ahead of the current playback position by the number of samples specified by this argument.
	 * If you specify 0 or omit this argument, the acquisition will be from the current playback position.
	 * @return Returns the number of samples acquired.
	 * @description Gets PCM data for visualization.
	 * Reads PCM data from the current playback position and writes it to the array specified by the buffer argument.
	 * However, there is a possibility that data cannot be read normally depending on the buffer state and playback format.
	 * This method is intended to be used from plugins written in C or C++, so you cannot, for example, specify a TJS array for the buffer argument.
	 * To use this method, you must specify WaveSoundBuffer.useVisBuffer property to true.
	 */
	function getVisBuffer( buffer, numsamples, channel, ahead=0);

	/**
	 * Playback position
	 *
	 * @description Represents the playback position in ms.
	 * Setting a value moves to that position.
	 */
	 property position {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Playback position
	 *
	 * @description Represents the playback position in number of samples.
	 * Setting a value moves to that position.
	 */
	 property samplePosition {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Whether paused
	 *
	 * @description Indicates whether it is in a paused state.
	 * You can also set a value. True is paused.
	 */
	 property paused {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Media playback time
	 *
	 * @description Represents the total playback time of the media in ms.
	 */
	 property totalTime {
		 getter() { return value; }
	}
	/**
	 * Whether to loop playback
	 *
	 * @description Indicates whether to loop playback.
	 * You can also set a value.
	 * If true is specified, loop playback will be performed.
	 * Even if false is specified, if the media being played has loop information, the loop information will be used.
	 */
	 property looping {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Volume
	 *
	 * @description Represents the playback volume.
	 * You can also set a value.
	 * Specify a value from 0 to 100000, where 0 is completely muted and 100000 is 100% volume.
	 */
	 property volume {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Second volume
	 *
	 * @description Represents the playback volume. You can set a value.
	 * The difference from the WaveSoundBuffer.volume property is that this property does not change even with the WaveSoundBuffer.fade method.
	 * The final volume is determined by the product of the volume property and this property.
	 * If the volume property is 100000 (100%) and the volume2 property is also 100000 (100%), then 100% × 100% = 100%, so it will be played at 100% volume.
	 * If the volume property is 50000 (50%) and the volume2 property is 75000 (75%), then 50% × 75% = 37.5%, so it will be played at 37.5% volume.
	 */
	 property volume2 {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Status
	 *
	 * @description Represents the current state.
	 * The state is represented by a string and takes the following values.
	 *
	 * + "unload" : Media is not open
	 * + "play" : Media is playing
	 * + "stop" : Media is stopped
	 *
	 */
	 property status {
		 getter() { return value; }
	}
	/**
	 * Whether to use visualization buffer
	 *
	 * @description Indicates whether to use the visualization buffer.
	 * You can also set a value.
	 * If true is specified, the visualization buffer becomes available and the WaveSoundBuffer.getVisBuffer method becomes available.
	 * It defaults to false.
	 * Note that specifying true will consume more memory and CPU time than specifying false.
	 */
	 property useVisBuffer {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Number of channels
	 *
	 * @description Represents the number of channels of the sound currently playing.
	 * It will be 1 for mono and 2 for stereo.
	 * May not return a normal value when the media is not open.
	 */
	 property channels {
		 getter() { return value; }
	}
	/**
	 * Sampling frequency
	 *
	 * @description Represents the sampling frequency of the sound currently playing.
	 * You can also set a value.
	 * If the sampling frequency is the same as a CD, it will be 44100.
	 * May not return a normal value when the media is not open.
	 * Setting a value will play at that frequency.
	 */
	 property frequency {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Number of quantization bits
	 *
	 * @description Represents the number of quantization bits of the sound currently playing.
	 * If the number of quantization bits is the same as a CD, it will be 16.
	 * May not return a normal value when the media is not open.
	 */
	 property bits {
		 getter() { return value; }
	}
	/**
	 * Flags
	 *
	 * @description You can get an object representing flags.
	 * This object has properties from 0 to 15, each representing the value of each flag.
	 * Properties can be accessed using the indirect member selection operator ('[ ]' operator).
	 * You can also set values for these properties.
	 * The value is in the range of 0 to 9999, and cannot be lower or higher than this.
	 * The count property of this object always returns 16.
	 * This object has a reset method, and executing this method resets all flags to 0.
	 * If the media is not open, setting values to the properties of this object will be ignored.
	 * This object may look like an array object at first glance, but it is not a so-called TJS array object (an object of the 'Array' class).
	 * Flags are all reset to 0 by the WaveSoundBuffer.open method.
	 * Example:
	 *
	 * ```
	 * var buf = new WaveSoundBuffer(window);
	 * (omitted)
	 * buf.flags.reset();
	 * // Reset all flags to 0
	 * var cnt = buf.flags.count;
	 * // cnt will be 16
	 * buf.flags[4] = 34;
	 * // Assign 34 to flag number 4
	 *```
	 *
	 */
	 property flags {
		 getter() { return value; }
	}
	/**
	 * Labels
	 *
	 * @description You can get an object representing labels.
	 * This object is a dictionary array, and each element contains the name of the label in the loop information as a member name.
	 * Each element is also a dictionary array, where the name member represents the name of the label, the position member represents the position of the label in milliseconds, and samplePosition represents the position of the label in number of samples.
	 * Consider this dictionary array to be read-only.
	 * Assigning values or creating new members will not be reflected.
	 * Example:
	 *
	 * ```
	 * var buf = new WaveSoundBuffer(window);
	 * (omitted)
	 * debug.message(buf.labels['start'].position);
	 * // Position of the label named 'start' in milliseconds
	 * debug.message(buf.labels['start'].samplePosition);
	 * // Position of the label named 'start' in number of samples
	 * ```
	 *
	 */
	 property labels {
		 getter() { return value; }
	}
	/**
	 * Pan
	 *
	 * @description Represents pan (sound image position).
	 * You can also set a value.
	 * You can specify the left and right position where the sound is heard.
	 * Specify a value from -100000 to 0 to 100000, where -100000 is completely left, 0 is center, and 100000 is completely right.
	 */
	 property pan {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Global volume
	 *
	 * @description Represents the global volume (master volume).
	 * You can also set a value.
	 * This volume affects all WaveSoundBuffers.
	 * Specify a value from 0 to 100000, where 0 is completely muted and 100000 is 100% volume.
	 * The default value is 100000.
	 * This property exists only on the WaveSoundBuffer class (this property does not exist on objects created from WaveSoundBuffer).
	 * When using, use WaveSoundBuffer.globalVolume.
	 */
	 property globalVolume {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Focus mode
	 *
	 * @description Represents the focus mode.
	 * You can also set a value.
	 * Focus mode is a mode that mutes when the application is minimized or becomes inactive.
	 *
	 * + If you specify sgfmNeverMute, it will not be muted no matter what state the application is in.
	 * + If you specify sgfmMuteOnMinimize, it will be muted when the application is minimized.
	 * + If you specify sgfmMuteOnDeactivate, it will be muted when the application becomes inactive.
	 *
	 * This property exists only on the WaveSoundBuffer class (this property does not exist on objects created from WaveSoundBuffer).
	 * When using, use WaveSoundBuffer.globalFocusMode.
	 * The setting of '-wsmute' (DirectSound mute) specified in the command line option takes precedence over the setting of this property.
	 * On Android, it will be muted when it becomes inactive.
	 * Processing speed decreases in the background, making normal playback impossible.
	 */
	 property globalFocusMode {
		 getter() { return value; }
		 setter( value ) {}
	}
	/**
	 * Filter array
	 *
	 * @description An array (an instance of the Array class) that holds insertion filter objects.
	 * By registering a filter object in this array, you can apply various effects to the audio in real time during playback.
	 * Changes to the filter array are only reflected when the WaveSoundBuffer.open method is executed.
	 * Until then, changes to this array will not be reflected.
	 * Example:
	 * ```
	 * var buf = new WaveSoundBuffer(window);
	 * (omitted)
	 * buf.filters.clear();
	 * // Clear the filter array
	 * buf.filters.add(new WaveSoundBuffer.PhaseVocoder());
	 * // Add PhaseVocoder filter
	 * buf.filters[0].time = 0.5;
	 * // Double speed playback
	 * ```
	 */
	 property filters {
		 getter() { return value; }
	}
};
